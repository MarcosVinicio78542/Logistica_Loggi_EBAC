# -*- coding: utf-8 -*-
"""Análise_Exploratoria_dados_Loggi.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1IVfGWdJ5yZi5INwPhM_PXEhL7Vj9J0ER

---

# **Análise Exploratória de Dados de Logística da Loggi**

## 1\. Contexto

A Loggi, empresa de logística do Brasil que opera principalmente no Distrito Federal, enfrenta desafios para atender à crescente demanda de entregas na região. Para lidar com isso, a empresa utiliza análise de dados para otimizar rotas, identificar padrões de entrega e melhorar a eficiência operacional. Isso permite à Loggi tomar decisões informadas e proativas para resolver problemas logísticos, garantindo uma experiência de entrega mais eficaz e satisfatória para os clientes do Distrito Federal.

Então a análise exploratória de dados é fundamental para a logística, pois permite compreender padrões, tendências e insights nos dados relacionados às operações de transporte, armazenagem e distribuição. Ao explorar os dados, os profissionais de logística podem identificar gargalos na cadeia de suprimentos, otimizar rotas de entrega, prever demandas futuras e melhorar a eficiência operacional. Essa análise fornece uma visão abrangente do desempenho logístico, permitindo tomadas de decisão mais embasadas e estratégias mais eficazes para atender às necessidades dos clientes e manter a competitividade no mercado.

## 2\. Pacotes e bibliotecas
"""

import json
import pandas as pd
import seaborn as sns
import geopandas
import matplotlib.pyplot as plt
import seaborn as sns
import numpy as np

from geopy.geocoders import Nominatim
from geopy.extra.rate_limiter import RateLimiter
from scipy.stats import kstest

pip show geopy

"""## 3\. Exploração de dados

*   Baixando arquivo **json** com dados da Loggi
"""

!wget -q "https://raw.githubusercontent.com/andre-marcos-perez/ebac-course-utils/main/dataset/deliveries.json" -O deliveries.json

# leando arquivo
with open('deliveries.json', mode='r', encoding='utf8') as file:
  data = json.load(file)

data[0].keys()  # inspecionar chaves dos primeiros elementos

deliveries_df = pd.DataFrame(data)  # Formando e exibindo data frame com dados brutos
deliveries_df.head()

deliveries_df.shape

"""


*   Normalizando a Coluna "origin"

"""

origin_df = pd.json_normalize(deliveries_df['origin'])
origin_df.head()

"""Veja que temos uma lista de dicionários da coluna "deliveries" que precisamos tratar"""

deliveries_df = pd.merge(left=deliveries_df, right= origin_df, how='inner', left_index=True, right_index=True)
deliveries_df = deliveries_df.drop("origin", axis=1)
deliveries_df = deliveries_df[["name", "region", "lng", "lat", "vehicle_capacity", "deliveries"]]
deliveries_df.rename(columns={"lng": "hub_lng", "lat": "hub_lat"}, inplace=True)
deliveries_df.head()

"""

* Normalizando Coluna "deliveries"

"""

deliveries_exploded_df = deliveries_df[["deliveries"]].explode("deliveries")

deliveries_normalized_df = pd.concat([
  pd.DataFrame(deliveries_exploded_df["deliveries"].apply(lambda record: record["size"])).rename(columns={"deliveries": "delivery_size"}),
  pd.DataFrame(deliveries_exploded_df["deliveries"].apply(lambda record: record["point"]["lng"])).rename(columns={"deliveries": "delivery_lng"}),
  pd.DataFrame(deliveries_exploded_df["deliveries"].apply(lambda record: record["point"]["lat"])).rename(columns={"deliveries": "delivery_lat"}),
], axis= 1)
deliveries_normalized_df.head()

""" Transformando em uma estrutura de dados aninhada"""

deliveries_df = deliveries_df.drop("deliveries", axis=1)
deliveries_df = pd.merge(left=deliveries_df, right=deliveries_normalized_df, how='right', left_index=True, right_index=True)
deliveries_df.reset_index(inplace=True, drop=True)
deliveries_df.head()

deliveries_df.shape

deliveries_df.info()

deliveries_df.drop(["name", "region"], axis=1).select_dtypes('int64').describe().transpose()

"""## 4\. Manipulação"""

hub_df = deliveries_df[["region", "hub_lng", "hub_lat"]]
hub_df = hub_df.drop_duplicates().sort_values(by="region").reset_index(drop=True)
hub_df.head()

""" Os códigos abaixo, usa a biblioteca geopy para obter informações de localização com base em coordenadas geográficas e imprime essas informações em formato JSON."""

geolocator = Nominatim(user_agent="ebac_geocoder")
location = geolocator.reverse("-15.657013854445248, -47.802664728268745")

print(json.dumps(location.raw, indent=2, ensure_ascii=False))

geocoder = RateLimiter(geolocator.reverse, min_delay_seconds=1)
hub_df["coordinates"] = hub_df["hub_lat"].astype(str)  + ", " + hub_df["hub_lng"].astype(str)
hub_df["geodata"] = hub_df["coordinates"].apply(geocoder)
hub_df.head()

hub_geodata_df = pd.json_normalize(hub_df["geodata"].apply(lambda data: data.raw))
hub_geodata_df.head()

hub_geodata_df.rename(columns={"address.town": "hub_town", "address.suburb": "hub_suburb", "address.city": "hub_city"}, inplace=True)
hub_geodata_df["hub_city"] = np.where(hub_geodata_df["hub_city"].notna(), hub_geodata_df["hub_city"], hub_geodata_df["hub_town"])
hub_geodata_df["hub_suburb"] = np.where(hub_geodata_df["hub_suburb"].notna(), hub_geodata_df["hub_suburb"], hub_geodata_df["hub_city"])
hub_geodata_df.drop("hub_town", axis=1, inplace=True)
hub_df = pd.merge(left=hub_df, right=hub_geodata_df, left_index=True, right_index=True)
hub_df = hub_df[["region", "hub_suburb", "hub_city"]]
hub_df.head()

deliveries_df = pd.merge(left=deliveries_df, right=hub_df, how="inner", on="region")
deliveries_df = deliveries_df[["name", "region", "hub_lng", "hub_lat", "hub_city", "hub_suburb", "vehicle_capacity", "delivery_size", "delivery_lng", "delivery_lat"]]
deliveries_df.head()

"""Arquivo com geocodificação reversa das entregas"""

!wget -q "https://raw.githubusercontent.com/andre-marcos-perez/ebac-course-utils/main/dataset/deliveries-geodata.csv" -O deliveries-geodata.csv

# lendo arquivo
deliveries_geodata_df = pd.read_csv("deliveries-geodata.csv")
deliveries_geodata_df.head()

deliveries_df = pd.merge(left=deliveries_df, right=deliveries_geodata_df[["delivery_city", "delivery_suburb"]], how="inner", left_index=True, right_index=True)
deliveries_df.head()

deliveries_df.info()

"""## 5\. Visualização"""

!wget -q "https://geoftp.ibge.gov.br/cartas_e_mapas/bases_cartograficas_continuas/bc100/go_df/versao2016/shapefile/bc100_go_df_shp.zip" -O distrito-federal.zip
!unzip -q distrito-federal.zip -d ./maps
!cp ./maps/LIM_Unidade_Federacao_A.shp ./distrito-federal.shp
!cp ./maps/LIM_Unidade_Federacao_A.shx ./distrito-federal.shx

mapa = geopandas.read_file("distrito-federal.shp")
mapa = mapa.loc[[0]]
mapa.head()
mapa.to_file("mapa.geojson", driver='GeoJSON')

mapa.head()

# criando o DataFrame geo_hub_df através do DataFrame deliveries_df. Note a nova coluna geometry
hub_df = deliveries_df[["region", "hub_lng", "hub_lat"]].drop_duplicates().reset_index(drop=True)
geo_hub_df = geopandas.GeoDataFrame(hub_df, geometry=geopandas.points_from_xy(hub_df["hub_lng"], hub_df["hub_lat"]))
geo_hub_df.head()

"""Mapa das Entregas"""

geo_deliveries_df = geopandas.GeoDataFrame(deliveries_df, geometry=geopandas.points_from_xy(deliveries_df["delivery_lng"], deliveries_df["delivery_lat"]))
geo_deliveries_df.head()
geo_deliveries_df.to_csv('geo_deliver.csv', index=False)

# cria o plot vazio
fig, ax = plt.subplots(figsize = (50/2.54, 50/2.54))

# plot mapa do distrito federal
mapa.plot(ax=ax, alpha=0.4, color="lightgrey")

# plot das entregas
geo_deliveries_df.query("region == 'df-0'").plot(ax=ax, markersize=2, color="red", label="região df-0")
geo_deliveries_df.query("region == 'df-1'").plot(ax=ax, markersize=1, color="blue", label="região df-1")
geo_deliveries_df.query("region == 'df-2'").plot(ax=ax, markersize=1, color="seagreen", label="região df-2")

# plot dos hubs
geo_hub_df.plot(ax=ax, markersize=30, marker="x", color="black", label="hub")

# plot da legenda
plt.title("Demandas de entregas no Distrito Federal por Região", fontdict={"fontsize": 16})
lgnd = plt.legend(prop={"size": 15})
for handle in lgnd.legendHandles:
    handle.set_sizes([50])

# propoções de entrega em cada região no mapa acima
data = pd.DataFrame(deliveries_df[['region', 'vehicle_capacity']].value_counts(normalize=True)).reset_index()
data.rename(columns={0: "region_percent"}, inplace=True)
data.head()

"""Pelo gráfico acima, concluímos que as regiões "df-1" e "df-2" localizadas mais no Sul de Brasília concentram maior demanda de entregas."""

co_values = geo_deliveries_df['delivery_size'].value_counts()

proporcao_valores = geo_deliveries_df['delivery_size'].value_counts(normalize=True)

# Criar um novo DataFrame para armazenar as contagens e proporções
Size_deliveries_df = pd.DataFrame({'Tamanho': co_values.index, 'Contagem': co_values.values, 'Proporção': proporcao_valores})
Size_deliveries_df

"""**Gráfico de Barras Tamanho das Entregas**"""

# tamanho da figura
plt.figure(figsize=(10, 6))

# Criando o gráfico de barras
bars = plt.bar(Size_deliveries_df['Tamanho'], Size_deliveries_df['Contagem'], color=['#1f77b4', '#ff7f0e', '#2ca02c', '#d62728', '#9467bd',
         '#8c564b', '#e377c2', '#7f7f7f', '#bcbd22', '#17becf'])

# Adicione rótulos de tamanho sobre cada barra
for bar in bars:
    height = bar.get_height()
    plt.text(bar.get_x() + bar.get_width()/2., height, '%d' % int(height),
             ha='center', va='bottom')

# título e rótulos aos eixos
plt.title('Contagem de Tamanhos de Ocupação de cada Entrega realizada no Distrito Federal')
plt.xlabel('Tamanho de Ocupação')
plt.ylabel('Quantidade de entregas')

# Exibindo o gráfico
plt.xticks(Size_deliveries_df['Tamanho'])
plt.show()

statistic, p_value = kstest(Size_deliveries_df['Tamanho'], 'norm')

print(f'Estatística de teste: {statistic:.2f}')
print(f'Valor p: {p_value}')

"""
Com base nos resultados do teste não paramétrico de Shapiro-Wilk, em que o valor-p é praticamente zero e a estatística de teste é 0.88, podemos inferir que os dados de tamanho de ocupação de cada entrega não seguem uma distribuição normal. Além disso, a estatística de teste de 0.88 indica que existe uma discrepância substancial entre a distribuição dos seus dados e uma distribuição normal.

A distribuição discreta dos dados sugere que os tamanhos de ocupação das entregas podem ser representados por números inteiros e são contáveis, o que é uma característica de uma distribuição discreta, em oposição a uma distribuição contínua."""